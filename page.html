<html>
  <head>
    <title>The crappy wikipedia quiz</title>
  </head>
  <body>
    <div id="app">
      <center>
        <h1>THE GREAT WIKIPEDIA QUIZ</h1>
      </center>
      <div v-if="playerName === undefined">
        <p>What is your name?</p>
        <input id="nameInput" onsubmit=onSubmitNameClick() type="text"/>
        <button id="nameSubmit" onclick=onSubmitNameClick()>Submit</button>
      </div>
      <div v-if="playerName">
        <h2>{{ activeQuestion.topic }}</h3>
        <h3>{{ activeQuestion.section }}</h3>
        <p>{{ activeQuestion.question }}</p>
        <div v-for="(val, index) in activeQuestion.answers">
          <button v-on:click="submitAnswer(index)" :disabled="answer">
            {{ val }}
          </button>
        </div>
        <div>
          <h2 v-if="correctAnswer === answer">CORRECT!</h2>
          <div v-if="answer !== undefined && correctAnswer !== answer">
            <h2>WRONG!</h2>
            <p>The correct answer is {{ activeQuestion.correct_answer }}</p>
          </iv>
        </div>
        <div>
          <h5>{{ countdownValue }}</h5>
        </div>
        <ul v-for="player in players">
          <li>{{ player.name  }}  {{ player.score }}</li>
        </ul>
      </div>
    </div>
  </body>
</html>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  const app = new Vue({
    el: "#app",
    data: {
      activeQuestion: {},
      answer: undefined,
      correctAnswer: undefined,
      countdownValue: 0,
      playerName: undefined,
      players: [],
    },
    methods: {
      submitAnswer,
    }
  });

  function submitAnswer(buttonNumber) {
    app.answer = buttonNumber;

    console.log(app.answer + " " + app.correctAnswer);

    fetch("http://localhost:8080/answer_question", {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      // FIXME: really shouldn't trust the client to say the answer is right...
      body: JSON.stringify({ 
        name: app.playerName,
        correct: app.correctAnswer === app.answer, 
      })
    }); 
  }

  async function onSubmitNameClick() {
    const playerResp = await fetch("http://localhost:8080/join_game", {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ name: nameInput.value })
    });
    app.playerName = nameInput.value;
  }

  function setQuestion(json) {
    app.answer = undefined;
    json.answers.forEach((answer, i) => {
      if (answer === json.correct_answer) app.correctAnswer = i;
    });
    json.topic = json.topic.replace(/_/g, " ");
    json.section = json.section.replace(/_/g, " ");
    app.activeQuestion = json;
  }

  function startCountdownTimer() {
    setInterval(() => {
      const newValue = parseFloat(app.countdownValue - 0.1).toFixed(1); 
      if (newValue > 0) {
        app.countdownValue = newValue;
      }
    }, 100);
  }

  async function getQuestionData() {
    const questionResp = await fetch("http://localhost:8080/get_current_question");
    const json = await questionResp.json();
    const activeQuestionStartTime = new Date(json["active_question_start_time"]);
    const questionTime = json["question_time"];
    const currentTime = new Date(new Date().toLocaleString("en-US", {timeZone: "UTC"}))
    activeQuestionStartTime.setSeconds(
      activeQuestionStartTime.getSeconds() + questionTime
    );

    return {
      json,
      currentTime,
      activeQuestionStartTime,
    };
  }

  function fetchNextQuestion(time) {
    // TODO: Add debounce for when server isn't updated quite yet or in an error condition.
    setTimeout(async () => {
      const { json, activeQuestionStartTime, currentTime } = await getQuestionData();
      app.players = json.players;
      app.countdownValue = json.question_time;
      setQuestion(json);
      fetchNextQuestion(activeQuestionStartTime.getTime() - currentTime.getTime())
    }, time)
  }

  async function setup() {
    const { json, activeQuestionStartTime, currentTime } = await getQuestionData();
    app.players = json.players;
    app.countdownValue = (activeQuestionStartTime - currentTime) / 1000;
    startCountdownTimer();
    setQuestion(json);
    fetchNextQuestion(activeQuestionStartTime.getTime() - currentTime.getTime());
  }

  setup();
</script>